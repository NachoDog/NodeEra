#!/usr/bin/env python3
'''
    Copyright: SingerLinks Consulting LLC dba NodeEra Software 2018-2019 - all rights reserved
    Confidential Material - Do Not Distribute - SingerLinks Consulting dba NodeEra Software
'''
import logging

from PyQt5.QtCore import QSettings

from core.helper import Helper
            
class SchemaModel():
    def __init__(self, parent = None, neoDriver = None ):
        super(SchemaModel, self).__init__()
        self.settings = QSettings()
        self.modelNeoDriver = neoDriver
        self.parent = parent
        self.helper = Helper()
        # model defaults
        self.updateTreeView = None
        
        # it is the applications responsibility to call the refreshModel function to populate the schema data

    def logMessage(self, msg):
            
        if logging:
            logging.info(msg)            


    def initModel(self, ):
        '''
        Initialize an empty schema model data structure
        '''
        self.schemaData = {}
        self.schemaData["TopLevel"] = ["Node Key","Node Property Unique",
                                                     "Node Property Exists","Relationship Property Exists",
                                                     "Index",
                                                     "Label", "Property", "Relationship", 
                                                     "User", 
                                                     "Role"
                                                     ]
            
        #create an empty list for each top level schema category
        for x in self.schemaData["TopLevel"]:
            self.schemaData[x] = []
    
    def matchConstraintRelTemplate(self, conList, propList, relName=None):
        for constraint in self.schemaData["Relationship Property Exists"]:
            if (constraint["property"] in propList and constraint.get("relationship", "")== relName):
                conList.append(["Property Exists", constraint["property"]])       

        
    def matchConstraintNodeTemplate(self, conList, lblList, propList):
        '''
        scan all defined Node constraints to see if any match the provided label and property list
        If there is a match, add the appropriate list to conList
        '''
        for constraint in self.schemaData["Node Key"]:
            if (constraint["label"] in lblList and set(constraint["properties"]).issubset(propList)):
                conList.append(["Node Key", constraint["label"], ','.join(constraint["properties"])])
        for constraint in self.schemaData["Node Property Unique"]:
            if (constraint["label"] in lblList and constraint["property"] in propList):
                conList.append(["Property Unique", constraint["label"], constraint["property"], ""]      )  
        for constraint in self.schemaData["Node Property Exists"]:
            if (constraint["label"] in lblList and constraint["property"] in propList):
                conList.append(["Property Exists", constraint["label"], constraint["property"], ""])       
                
    def matchIndexNodeTemplate(self, idxList, lblList, propList):
        '''
        scan all defined Node indexes to see if any match the provided label and property list
        If there is a match, add the appropriate list to idxList
        '''
        for index in self.schemaData["Index"]:
            idxLbl = index.get("label", None)
            idxProp = index.get("properties", None)
            if (not idxLbl is None and not idxProp is None): 
                # see if the index label and property list is in the node template label list and property list
                if (set([index["label"]]).issubset(lblList) and set(index["properties"]).issubset(propList)):
                    # now see if this index is generated by a constraint or is a user defined index
                    if self.indexAutoGenerate(index) == True:
                        idxList.append(["Yes", index["label"], ','.join(index["properties"])])
                    else:
                        idxList.append(["No", index["label"], ','.join(index["properties"])])
                    
    def indexAutoGenerate(self, index):
        for constraint in self.schemaData["Node Key"]:
            if (set([index["label"]]).issubset([constraint["label"]]) and set(index["properties"]).issubset(constraint["properties"])):
                return True
        for constraint in self.schemaData["Node Property Unique"]:
            if (index["label"] == constraint["label"] and index["properties"][0] == constraint["property"]):
                return True
        return False
        
    def refreshModel(self, ):
        '''
        query the graph to find all schema objects
        '''
        self.initModel()
#        QApplication.setOverrideCursor(Qt.WaitCursor)
        rc, msg = self.getIndexes()
        if rc == False:
            return rc, msg
        rc, msg = self.getConstraints()    
        if rc == False:
            return rc, msg
        rc, msg = self.getLabels()
        if rc == False:
            return rc, msg
        rc, msg = self.getProperties()
        if rc == False:
            return rc, msg
        rc, msg = self.getRelationships()
        if rc == False:
            return rc, msg
#        rc, msg = self.getUsers()
#        if rc == False:
#            return rc, msg
#        rc, msg = self.getRoles()
#        if rc == False:
#            return rc, msg
            
        self.logMessage("Schema Model Refresh Complete - {}".format(self.modelNeoDriver.name))
        return True, "Schema Model Refresh Complete - {}".format(self.modelNeoDriver.name)


    def testSchemaConnection(self, ):
        '''
        This method will run a simple match to test the connection.
        Return True, Msg if it works
        Return False, Msg if it doesn't work
        '''
        try:
            rc, msg = self.modelNeoDriver.runCypherAuto("match (n) return n limit 1")
        except Exception as e:
            return False, repr(e)
            
        return rc, msg
        
    def getIndexes(self, ):
        '''
        get list of indexes from neo4j
        '''
        try:
            cypher = 'call db.indexes()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                # convert the records to dictionaries so we can add a name property
                for rec in self.modelNeoDriver.resultSet:
                    self.schemaData["Index"].append(rec.data())
#                self.schemaData["Index"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["Index"]:
                    # make the "name" property the create statement to be consistent with how the constraints are handled.  This should be improved.
                    propList = index["properties"]
                    propComma = ",".join(x for x in propList) 
                    if "labelsOrTypes" in index:
                        lbl = index["labelsOrTypes"][0]
                    elif "tokenNames" in index:
                        lbl = index["tokenNames"][0]     
                    else:
                        lbl = "no label"
                    newName = "INDEX ON :{}({})".format(lbl, str(propComma))                    
                    index['name'] = newName
#                    # hack to support v3x which has indexName property and not a name property
#                    if 'indexName' in index:
#                        index['name'] = index['indexName']
#                    if not 'name' in index:
#                        index['name'] = "no name"
#                    # need to generate a description of the index
#                    if not 'description' in index:
#                        index["description"] = "no description"
                msg = "Indexes retrieved {}".format(self.schemaData["Index"] )        
            else:
                msg = "Get Indexes Error {}".format(msg1)
                self.logMessage(msg) 
        except BaseException as e:
            msg = "{} - Get Indexes failed.".format(repr(e))
            self.logMessage(msg) 
        finally: 
            return rc1, msg
            

        
    def getUsers(self, ):
        '''
        get list of users from neo4j
        '''
        try:
            cypher = 'call dbms.security.listUsers()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                self.schemaData["User"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["User"]:
                    index["name"] = index["username"]
                msg = "Users retrieved {}".format(self.schemaData["User"] )        
            else:
                msg = "Get Users Error {}".format(msg1)
                self.logMessage(msg) 
        except BaseException as e:
            msg = "{} - Get Users failed.".format(repr(e))
            self.logMessage(msg) 
        finally: 
            return rc1, msg

    def getRoles(self, ):
        '''
        get list of roles from neo4j
        '''
        try:
            cypher = 'call dbms.security.listRoles()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                self.schemaData["Role"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["Role"]:
                    index["name"] = index["role"]
                msg = "Roles retrieved {}".format(self.schemaData["Role"] )        
            else:
                msg = "Get Roles Error {}".format(msg1)
                self.logMessage(msg) 
        except BaseException as e:
            msg = "{} - Get Roles failed.".format(repr(e))
            self.logMessage(msg) 
        finally: 
            return rc1, msg

    def getRoleUsers(self, roleName=None):
        '''
        get list of users for a specific role
        '''
        roleUsers = []
        try:
            cypher = "CALL dbms.security.listUsersForRole('{}')".format(roleName)
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                roleUsers = [row["value"] for row in self.modelNeoDriver.resultSet]
                msg = "Roles retrieved {}".format(str(roleUsers) )        
            else:
                msg = "Get Roles Error {}".format(msg1)
                self.logMessage(msg)
        except BaseException as e:
            msg = "{} - Get Roles failed.".format(repr(e))
            self.logMessage(msg)
        finally: 
            
            return roleUsers
            
    def getUserRoles(self, userName=None):
        '''
        get list of roles for a specific user
        '''
        userRoles = []
        try:
            cypher = "CALL dbms.security.listRolesForUser('{}')".format(userName)
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                userRoles = [row["value"] for row in self.modelNeoDriver.resultSet]
                msg = "Roles retrieved {}".format(str(userRoles) )        
            else:
                msg = "Get Roles Error {}".format(msg1)
                self.logMessage(msg)
        except BaseException as e:
            msg = "{} - Get Roles failed.".format(repr(e))
            self.logMessage(msg)
        finally: 
            
            return userRoles
        
    
    def getConstraints(self, ):
        '''
        get list of constraints from neo4j
        '''
        try:
            cypher = 'call db.constraints()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                # convert result records to dictionaries
                resultDict = []
                for rec in self.modelNeoDriver.resultSet:
                    resultDict.append(rec.data())
                # figure out what kind of constraint it is
#                for result in self.modelNeoDriver.resultSet:
                for result in resultDict:
                    if result["description"].upper().find("UNIQUE") > -1:
                        self.schemaData["Node Property Unique"].append(result)
                    elif (result["description"].lower().find("exists") > -1 and result["description"].find("[") > -1):
                        self.schemaData["Relationship Property Exists"].append(result) 
                    elif result["description"].lower().find("exists") > -1:
                        self.schemaData["Node Property Exists"].append(result) 
                    elif result["description"].upper().find("NODE KEY") > -1:
                        self.schemaData["Node Key"].append(result) 

                # decompose the constraint definition statement
                for constraint in self.schemaData["Node Key"]:
                    constraint["name"] = constraint["description"]
                    self.deconstructNodeKey(constraint)
                for constraint in self.schemaData["Node Property Unique"]:
                    constraint["name"] = constraint["description"]
                    self.deconstructNPU(constraint)
                for constraint in self.schemaData["Node Property Exists"]:
                    constraint["name"] = constraint["description"]
                    self.deconstructNPE(constraint)
                for constraint in self.schemaData["Relationship Property Exists"]:
                    constraint["name"] = constraint["description"]
                    self.deconstructRPE(constraint)
                    
                msg = "Constraints retrieved {}".format(self.modelNeoDriver.resultSet )        
            else:
                msg = "Get Constraints Error {}".format(msg1)
                self.logMessage(msg)
        except BaseException as e:
            msg = "{} - Get Constraints failed.".format(repr(e))
            self.logMessage(msg)
        finally: 
            return rc1, msg
    
    def deconstructNodeKey(self, constraint=None):
        '''
        find the label and the list of properties in the Node Key constraint definition statement
        '''
        constraint["label"] = None
        try:
            con = constraint["description"]
            # find the prefix
            firstOP = con.find("(")
            firstColon = con.find(":")
            prefix = (con[firstOP+1:firstColon]).strip()
            # find the label
            closeParen = con.find(")")
            label = con[int(firstColon+1):closeParen].strip()
            constraint["label"] = label
            # find the properties
            pstart = con.upper().find("ASSERT") + 6
            pend = con.upper().find("IS NODE KEY") -1
            plist = (con[pstart:pend]).replace(prefix+".", "")
            plist = (((((plist.replace("(", "")).replace(")", "")).replace(" ", ""))).strip()).split(",")
            constraint["properties"] = plist
            
        except BaseException as e:
            msg = "{} - Parse Constraints failed on {}.".format(repr(e), con)
            self.logMessage(msg)
            
    def deconstructNPU(self, constraint=None):
        '''
        find the label and the property in the constraint definition statement
        '''
        constraint["label"] = None
        constraint["property"] = None
        try:
            con = constraint["description"]
            # find the prefix
            firstOP = con.find("(")
            firstColon = con.find(":")
            prefix = (con[firstOP+1:firstColon]).strip()
            # find the label
            firstColon = con.find(":")
            closeParen = con.find(")")
            label = con[int(firstColon+1):closeParen].strip()
            constraint["label"] = label
            # find the property
            pstart = con.upper().find("ASSERT") + 6
            pend = con.upper().find("IS UNIQUE") -1
            plist = ((con[pstart:pend]).replace(prefix+".", "")).strip()
            constraint["property"] = plist
            
        except BaseException as e:
            msg = "{} - Parse Constraints failed on {}.".format(repr(e), con)
            self.logMessage(msg)        
        
    def deconstructNPE(self, constraint=None):
        '''
        find the label and the property in the node property exists constraint definition statement
        '''
        constraint["label"] = None
        constraint["property"] = None
        try:
            con = constraint["description"]
            # find the prefix
            firstOP = con.find("(")
            firstColon = con.find(":")
            prefix = (con[firstOP+1:firstColon]).strip()
            # find the label
            firstColon = con.find(":")
            closeParen = con.find(")")
            label = con[int(firstColon+1):closeParen].strip()
            constraint["label"] = label
            # find the property
            pstart = con.upper().find("EXISTS(") + 7
            pend = con.upper().rfind(")")
            plist = ((con[pstart:pend]).replace(prefix+".", "")).strip()
            constraint["property"] = plist
            
        except BaseException as e:
            msg = "{} - Parse Constraints failed on {}.".format(repr(e), con)
            self.logMessage(msg)              
          
          
    def deconstructRPE(self, constraint=None):
        '''
        find the rel name and the property in the rel property exists constraint definition statement
        '''
        constraint["relationship"] = None
        constraint["property"] = None
        try:
            con = constraint["description"]
            # find the prefix
            firstBr = con.find("[")
            firstColon = con.find(":")
            prefix = (con[firstBr+1:firstColon]).strip()
            # find the relationship name
            lastBr = con.find("]")
            label = con[int(firstColon+1):lastBr].strip()
            constraint["relationship"] = label
            # find the property
            pstart = con.upper().find("EXISTS(") + 7
            pend = con.upper().rfind(")")
            plist = ((con[pstart:pend]).replace(prefix+".", "")).strip()
            constraint["property"] = plist
            
        except BaseException as e:
            msg = "{} - Parse Constraints failed on {}.".format(repr(e), con)
            self.logMessage(msg)              
       
        
    def getLabels(self, ):
        '''
        get list of Labels from neo4j
        '''
        try:
            cypher = 'call db.labels()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                # convert the records to dictionaries so we can add a name property
                for rec in self.modelNeoDriver.resultSet:
                    self.schemaData["Label"].append(rec.data())
#                self.schemaData["Label"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["Label"]:
                    index["name"] = index["label"]
                msg = "Labels retrieved {}".format(self.schemaData["Label"] )        
            else:
                msg = "Get Labels Error {}".format(msg1)
                self.logMessage(msg) 
        except BaseException as e:
            msg = "{} - Get Labels failed.".format(repr(e))
            self.logMessage(msg) 
        finally: 
            return rc1, msg
            
    def getProperties(self, ):
        '''
        get list of Properties from neo4j
        '''
        try:
            cypher = 'call db.propertyKeys()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                # convert the records to dictionaries so we can add a name property
                for rec in self.modelNeoDriver.resultSet:
                    self.schemaData["Property"].append(rec.data())
#                self.schemaData["Property"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["Property"]:
                    index["name"] = index["propertyKey"]
                msg = "Properties retrieved {}".format(self.schemaData["Property"] )        
            else:
                msg = "Get Properties Error {}".format(msg1)
                self.logMessage(msg)     
        except BaseException as e:
            msg = "{} - Get Properties failed.".format(repr(e))
            self.logMessage(msg)     
        finally: 
            return rc1, msg   

    def getRelationships(self, ):
        '''
        get list of Relationships from neo4j
        '''
        try:
            cypher = 'call db.relationshipTypes()'
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypher)
            if rc1:
                # convert the records to dictionaries so we can add a name property
                for rec in self.modelNeoDriver.resultSet:
                    self.schemaData["Relationship"].append(rec.data())
#                self.schemaData["Relationship"] = self.modelNeoDriver.resultSet
                # create a common "name" key
                for index in self.schemaData["Relationship"]:
                    index["name"] = index["relationshipType"]
                msg = "Relationships retrieved {}".format(self.schemaData["Relationship"] )        
            else:
                msg = "Get Relationships Error {}".format(msg1)
                self.logMessage(msg)     
        except BaseException as e:
            msg = "{} - Get Relationships failed.".format(repr(e))
            self.logMessage(msg)     
        finally: 
            return rc1, msg   
            
    def setUpdateTreeViewMethod(self, method=None):
        if not (method is None):
            self.updateTreeView = method
            
    def updateTV(self, ):
        if not (self.updateTreeView is None):
            self.updateTreeView()

####################################################################################################
# the following methods generically process any top level object
####################################################################################################
    def objectExists(self, topLevel=None,objectName=None ):
        if topLevel is not None and objectName is not None:
            for index, listObject in enumerate(self.schemaData[topLevel]):
                if listObject["name"] == objectName:            
                    return True
        return False
    
    def getDictByName(self, topLevel=None,objectName=None):
        if topLevel is not None and objectName is not None:
            for index, listObject in enumerate(self.schemaData[topLevel]):
                if listObject["name"] == objectName:            
                    return index, listObject
        return None, None
                
    def instanceList(self, listName):
        '''
        Return a List of name properties from the toplevel dictionary listName
        if listName = "Node Template" you will get back a list of all the node template names
        ''' 
        try:
            returnList = []
            searchDict = self.schemaData[listName]
            for index, object in enumerate(searchDict):
                returnList.append(object["name"])
        except:
            pass
        return returnList
    
    def instanceTopLevelIndex(self, listName, objectName):
        try:
            searchDict = self.schemaData[listName]
            for index, object in enumerate(searchDict):
                if object["name"] == objectName:
                    return index
        except:
            return None
        return None

#########################################################################
# Schema Object Methods
#########################################################################
    def createUser(self, userName):
        try:
            cypherCmd = "CALL dbms.security.createUser('{}','changeonfirstlogon',TRUE)".format(userName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "User Created"       
            else:
                msg = "User Create Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - User Create failed.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg
            
    def createRole(self, roleName=None):
        try:
            cypherCmd = "CALL dbms.security.createRole('{}')".format(roleName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Role Created"       
            else:
                msg = "Role Create Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Role Create failed.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg 
 
    def addUserRole(self, userName=None, role=None):
        '''
        Add a Role to a User
        '''
        try:
            cypherCmd = "CALL dbms.security.addRoleToUser('{}','{}')".format(role, userName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Role Added To User"       
            else:
                msg = "Add Role To User Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Add Role To User.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg  

    def removeUserRole(self, userName=None, role=None):
        '''
        Remove a Role from a User
        '''
        try:
            cypherCmd = "CALL dbms.security.removeRoleFromUser('{}','{}')".format(role, userName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Role Removed From User"       
            else:
                msg = "Remove Role From User Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Remove Role From User Error.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg  

    def getUserFlags(self, userName=None):
        try:
            userFlags = []
            cypherCmd = "CALL dbms.security.listUsers()"
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                for user in self.modelNeoDriver.resultSet:
                    if user["username"] == userName:
                        userFlags = user["flags"]
                msg = "Retrieved User Flags  [{}] for {}".format(userFlags, userName)       
            else:
                msg = "Get User Flags Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Get User Flags Error.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return userFlags

    def activateUser(self, userName=None):
        try:
            cypherCmd = "CALL dbms.security.activateUser('{}', True)".format(userName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "User Activated"       
            else:
                msg = "Activate User Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Activate User Error.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg  
            
    def suspendUser(self, userName=None):
        try:
            cypherCmd = "CALL dbms.security.suspendUser('{}')".format(userName)
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "User Suspended"       
            else:
                msg = "Suspend User Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Suspend User Error.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg      

    def changePassword(self, userName=None, pw=None, forceChange=None):
        try:
            cypherCmd = "CALL dbms.security.changeUserPassword('{}','{}',{})".format(userName, pw, str(forceChange))
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Password Changed"       
            else:
                msg = "Change Password Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Change Password Error.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg                  
            
    def createIndex(self, cypherCmd):
        try:
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Index Created"       
            else:
                msg = "Index Create Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Index Create failed.".format(repr(e))
        finally: 
            self.logMessage(msg) 
            return rc1, msg
            
    def createConstraint(self, cypherCmd):
        try:
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Constraint Created"       
            else:
                msg = "Constraint Create Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Constraint Create failed.".format(repr(e))
        finally: 
            self.logMessage(msg)  
            return rc1, msg

    def dropObject(self, cypherCmd):
        try:
            self.logMessage("Attempting: {}".format(cypherCmd))
            #run the query
            rc1, msg1 = self.modelNeoDriver.runCypherAuto(cypherCmd)
            if rc1:
                msg = "Object Dropped"       
            else:
                msg = "Drop Object Error {}".format(msg1)
        except BaseException as e:
            msg = "{} - Drop Object failed.".format(repr(e))
        finally: 
            self.logMessage(msg)  
            return rc1, msg

    def genMatchFromConstraint(self, objectName=None, objectType=None):
        '''
        Generate cypher match statements for constraints and indexes
        '''
        try:
            cypher = "Error Generating Cypher"
            if objectType == "Node Key":
                properties = []
                for constraint in self.schemaData["Node Key"]:
                    if objectName == constraint["name"]:
                        p1 = constraint["label"]
                        properties = constraint["properties"]
                        p2 = ' and '.join(" exists(n." + prop + ") \n" for prop in properties)
                        p3 = "n:{} as {},\n".format(p1, p1)
                        p4 = (''.join("n." + prop + " as " + prop + ",\n" for prop in properties)) 
                        cypher = '''MATCH (n:{}) \nWHERE {}RETURN id(n) as NodeID, \n{}{}n as Node  '''.format(p1, p2, p3, p4)
            
            elif objectType == "Node Property Unique":   
                properties = []
                for constraint in self.schemaData[objectType]:
                    if objectName == constraint["name"]:
                        p1 = constraint["label"]
                        # this hack is needed to remove the parens from the property value
                        fixProp = constraint["property"].replace("(", "").replace(")", "")
                        properties.append(fixProp)  
                        p2 = ' and '.join(" exists(n." + prop + ") \n" for prop in properties)
                        p3 = "n:{} as {},\n".format(p1, p1)
                        p4 = (''.join("n." + prop + " as " + prop + ",\n" for prop in properties)) 
                        cypher = '''MATCH (n:{}) \nWHERE {}RETURN id(n) as NodeID, \n{}{}n as Node  '''.format(p1, p2, p3, p4)
            
            elif objectType == "Node Property Exists":   
                properties = []
                for constraint in self.schemaData[objectType]:
                    if objectName == constraint["name"]:
                        p1 = constraint["label"]
                        properties.append(constraint["property"])
                        p2 = ' and '.join(" exists(n." + prop + ") \n" for prop in properties)
                        p3 = "n:{} as {},\n".format(p1, p1)
                        p4 = (''.join("n." + prop + " as " + prop + ",\n" for prop in properties)) 
                        cypher = '''MATCH (n:{}) \nWHERE {}RETURN id(n) as NodeID, \n{}{}n as Node  '''.format(p1, p2, p3, p4)

            elif objectType == "Relationship Property Exists":   
                properties = []
                for constraint in self.schemaData[objectType]:
                    if objectName == constraint["name"]:
                        p1 = constraint["relationship"]
                        properties.append(constraint["property"])
                        p2 = ' and '.join(" exists(r." + prop + ") \n" for prop in properties)
                        p3 = "type(r) as RelName,\n"
                        p4 = (''.join("r." + prop + " as " + prop + ",\n" for prop in properties)) 
                        cypher = '''MATCH ()-[r:{}]->() \nWHERE {}RETURN id(r) as RelID, \n{}{}r as Relationship  '''.format(p1, p2, p3, p4)
            
            elif objectType == "Index":
                properties = []
                for constraint in self.schemaData[objectType]:
                    if objectName == constraint["name"]:
                        if 'labelsOrTypes' in constraint:
                            p1 = constraint["labelsOrTypes"][0]
                        elif 'tokenNames' in constraint:
                            p1 = constraint["tokenNames"][0]    
                        else:
                            p1 = "no Label"

                        properties = constraint["properties"]
                        p2 = ' and '.join(" exists(n." + prop + ") \n" for prop in properties)
                        p3 = "n:{} as {},\n".format(p1, p1)
                        p4 = (''.join("n." + prop + " as " + prop + ",\n" for prop in properties)) 
                        cypher = '''MATCH (n:{}) \nWHERE {}RETURN id(n) as NodeID, \n{}{}n as Node  '''.format(p1, p2, p3, p4)

            elif objectType == "Label":
                p1 = objectName
                p3 = "n:{} as {},\n".format(p1, p1)
                cypher = '''MATCH (n:{}) \nRETURN id(n) as NodeID, \n{}n as Node  '''.format(p1, p3)
            
            elif objectType == "Property":   
                p1 = "exists(n.{})\n".format(objectName)
                p2 = "n.{} as {},\n".format(objectName, objectName)
                cypher = '''MATCH (n) \nWHERE {}RETURN id(n) as NodeID, \n{}n as Node  '''.format(p1, p2)

            elif objectType == "Relationship":   
                        p1 = objectName
                        cypher = '''MATCH (f)-[r:{}]->(t) \nRETURN id(r) as RelID,\ntype(r) as RelName,\nr as Relationship,\nf as FromNode,\nt as ToNode  '''.format(p1)
            

        except BaseException as e:    
            cypher = "Error Generating Cypher" 
            self.logMessage("Error Generating Cypher: {}".format(repr(e)))  
            
        finally:
            result = cypher + " ;"
            return result
        
        
            
